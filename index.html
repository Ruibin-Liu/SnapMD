<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>SnapMD</title>
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
      height: 100vh;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }
    .toolbar {
      padding: 6px 16px;
      background: #e9ecef;
      border-bottom: 1px solid #dee2e6;
      display: flex;
      gap: 10px;
      align-items: center;
      font-size: 13px;
    }
    .main-container {
      display: flex;
      flex: 1;
      height: calc(100vh - 34px);
      overflow: hidden;
      position: relative;
    }
    .sidebar {
      width: 250px;
      min-width: 200px;
      max-width: 350px;
      background: #f8f9fa;
      border-right: 1px solid #e9ecef;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      transition: width 0.2s ease;
      position: relative;
    }
    .sidebar.collapsed {
      width: 40px;
      min-width: 40px;
    }
    .sidebar.collapsed .sidebar-content {
      display: none;
    }
    .sidebar-header {
      padding: 4px 12px;
      background: #e9ecef;
      border-bottom: 1px solid #dee2e6;
      font-size: 12px;
      font-weight: 600;
      color: #495057;
    }
    .sidebar.collapsed .sidebar-header {
      display: none;
    }
    .search-box {
      padding: 2px 12px;
    }
    .search-box input {
      width: 100%;
      padding: 4px 8px;
      border: 1px solid #ced4da;
      border-radius: 4px;
      font-size: 12px;
      outline: none;
      background: white;
    }
    .search-box input:focus {
      border-color: #007bff;
      box-shadow: 0 0 0 2px rgba(0,123,255,0.1);
    }
    .sidebar-content {
      flex: 1;
      overflow-y: auto;
      padding: 4px 0;
    }
    .sidebar-content.drag-over {
      background: rgba(0, 123, 255, 0.1);
    }
    .sidebar-item {
      padding: 6px 10px;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 6px;
      border-radius: 3px;
    }
    .sidebar-item:hover {
      background: #e9ecef;
    }
    .sidebar-item.active {
      background: #dee2e6;
      font-weight: 500;
    }
    .sidebar-item-icon {
      font-size: 20px;
      width: 24px;
      text-align: center;
      flex-shrink: 0;
    }
    .sidebar-item-name {
      flex: 1;
      font-size: 13px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .sidebar-item-actions {
      display: none;
      gap: 4px;
    }
    .sidebar-item:hover .sidebar-item-actions {
      display: flex;
    }
    .sidebar-item-action-btn {
      background: none;
      border: none;
      color: #999;
      cursor: pointer;
      padding: 4px 8px;
      font-size: 20px;
      border-radius: 3px;
    }
    .sidebar-item-action-btn:hover {
      background: #dee2e6;
      color: #212529;
    }
    .sidebar-children {
      margin-left: 20px;
    }
    .sidebar-chevron {
      font-size: 18px;
      cursor: pointer;
      user-select: none;
      color: #666;
      width: 24px;
      height: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: transform 0.15s ease;
    }
    .sidebar-chevron:hover {
      color: #212529;
      background: #dee2e6;
      border-radius: 3px;
    }
    .sidebar-chevron.expanded {
      transform: rotate(90deg);
    }
    .sidebar-toggle {
      position: absolute;
      right: -10px;
      top: 50%;
      transform: translateY(-50%);
      width: 20px;
      height: 40px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: #f8f9fa;
      border: 1px solid #dee2e6;
      border-radius: 4px;
      cursor: pointer;
      z-index: 10;
      transition: transform 0.2s ease;
    }
    .sidebar-toggle:hover {
      background: #e9ecef;
    }
    .sidebar.collapsed .sidebar-toggle {
      right: 10px;
      transform: translateY(-50%) rotate(180deg);
    }
    .content-container {
      flex: 1;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }
    .split-container {
      display: flex;
      flex: 1;
      height: 100%;
      overflow: hidden;
    }
    .panel {
      flex: 1;
      display: flex;
      flex-direction: column;
      height: 100%;
      min-width: 0;
      overflow: hidden;
    }
    .panel:first-child {
      border-right: 1px solid #e9ecef;
    }
    .panel-header {
      padding: 4px 12px;
      background: #f8f9fa;
      border-bottom: 1px solid #e9ecef;
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 12px;
      font-weight: 600;
      color: #6c757d;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    #editor {
      flex: 1;
      padding: 16px;
      border: none;
      resize: none;
      font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
      font-size: 14px;
      line-height: 1.6;
      outline: none;
    }
    #preview {
      flex: 1;
      padding: 24px;
      overflow-y: auto;
      line-height: 1.6;
      scroll-behavior: smooth;
    }
    #preview h1, #preview h2, #preview h3 {
      margin-top: 1.5em;
      margin-bottom: 0.5em;
    }
    #preview p {
      margin-bottom: 1em;
    }
    #preview ul, #preview ol {
      margin-left: 2em;
      margin-bottom: 1em;
    }
    #preview code {
      background: #f4f4f4;
      padding: 2px 6px;
      border-radius: 3px;
      font-family: 'Monaco', 'Menlo', monospace;
      font-size: 0.9em;
    }
    #preview pre {
      background: #f4f4f4;
      padding: 16px;
      border-radius: 6px;
      overflow-x: auto;
      margin-bottom: 1em;
    }
    #preview pre code {
      background: none;
      padding: 0;
    }
    #preview blockquote {
      border-left: 4px solid #ddd;
      padding-left: 16px;
      margin: 1em 0;
      color: #666;
    }
    #preview a {
      color: #0066cc;
      text-decoration: none;
    }
    #preview a:hover {
      text-decoration: underline;
    }
    #preview img {
      max-width: 100%;
      height: auto;
    }
    .menu-item {
      cursor: pointer;
      padding: 4px 8px;
      border-radius: 3px;
    }
    .menu-item:hover {
      background: #dee2e6;
    }
    .dropdown {
      position: relative;
      display: inline-block;
    }
    .dropdown-content {
      display: none;
      position: absolute;
      background: white;
      min-width: 150px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.15);
      border-radius: 4px;
      padding: 4px 0;
      z-index: 100;
      top: 100%;
      left: 0;
    }
    .dropdown-content.show {
      display: block;
    }
    .dropdown-content div {
      display: block;
      padding: 8px 16px;
      color: #333;
      font-size: 13px;
      cursor: pointer;
    }
    .dropdown-content div:hover {
      background: #f8f9fa;
    }
    .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.5);
      z-index: 1000;
      align-items: center;
      justify-content: center;
    }
    .modal.show {
      display: flex;
    }
    .modal-content {
      background: white;
      padding: 24px;
      border-radius: 8px;
      max-width: 500px;
      width: 90%;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
    }
    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 16px;
    }
    .modal-header h2 {
      font-size: 18px;
      font-weight: 600;
      color: #333;
      margin: 0;
    }
    .modal-close {
      background: none;
      border: none;
      font-size: 24px;
      cursor: pointer;
      color: #666;
      padding: 0;
      line-height: 1;
    }
    .modal-close:hover {
      color: #333;
    }
    .shortcut-list {
      list-style: none;
      padding: 0;
      margin: 0;
    }
    .shortcut-list li {
      padding: 8px 0;
      border-bottom: 1px solid #f0f0f0;
      display: flex;
      align-items: center;
    }
    .shortcut-list li:last-child {
      border-bottom: none;
    }
    .shortcut-key {
      background: #f5f5f5;
      border: 1px solid #ddd;
      border-radius: 4px;
      padding: 4px 8px;
      font-family: 'Monaco', 'Menlo', monospace;
      font-size: 12px;
      margin-right: 12px;
      white-space: nowrap;
    }
    .shortcut-desc {
      flex: 1;
      color: #555;
      font-size: 14px;
    }
    </style>
</head>
<body>
  <div class="toolbar">
    <div class="dropdown">
      <div class="menu-item" id="menu-file">File</div>
      <div id="file-menu" class="dropdown-content">
        <div id="menu-new-file">New File</div>
        <div id="menu-new-folder">New Folder</div>
        <div id="menu-open">Open .md</div>
        <div id="menu-download">Download .md</div>
        <div id="menu-export">Export PDF</div>
        <hr style="margin: 4px 0; border: none; border-top: 1px solid #e9ecef;">
        <div id="menu-export-zip">Export Project as ZIP</div>
        <div id="menu-import-zip">Import from ZIP</div>
      </div>
    </div>
    <div class="menu-item" id="menu-clear">Clear</div>
    <div class="menu-item" id="menu-help">?</div>
    <input type="file" id="file-input" accept=".md,.markdown,.txt" style="display: none;">
    <input type="file" id="zip-input" accept=".zip" style="display: none;">
  </div>

  <div class="modal" id="help-modal">
    <div class="modal-content">
      <div class="modal-header">
        <h2>Help</h2>
        <button class="modal-close" id="close-help">√ó</button>
      </div>

      <div class="shortcut-list">
        <li>
          <span class="shortcut-key">Cmd/Ctrl + Shift + L</span>
          <span class="shortcut-desc">Create anchor at selected text</span>
        </li>
        <li>
          <span class="shortcut-key">Cmd/Ctrl + V</span>
          <span class="shortcut-desc">Paste URL ‚Üí Create inline link</span>
        </li>
        <li>
          <span class="shortcut-key">Cmd/Ctrl + V</span>
          <span class="shortcut-desc">Paste with anchor ‚Üí Create link to anchor</span>
        </li>
      </div>
    </div>
  </div>

  <div class="main-container">
    <div class="sidebar" id="sidebar">
      <div class="sidebar-toggle" id="sidebar-toggle">‚óÄ</div>
      <div class="sidebar-header" id="sidebar-header">
        <div class="search-box">
          <input type="text" id="search-input" placeholder="Search...">
        </div>
      </div>
      <div class="sidebar-content" id="sidebar-content"></div>
    </div>

  <div class="content-container">
      <div class="split-container">
        <div class="panel">
          <div class="panel-header">Editor</div>
          <textarea id="editor" placeholder="# Start typing your markdown here..."></textarea>
        </div>
        <div class="panel">
          <div class="panel-header">Preview</div>
          <div id="preview"></div>
        </div>
      </div>
    </div>
  </div>

  <script>
    const editor = document.getElementById('editor');
    const preview = document.getElementById('preview');
    const sidebarContent = document.getElementById('sidebar-content');
    const searchInput = document.getElementById('search-input');

    let data = getStorage();
    let currentFileId = null;
    let currentFolderId = null;
    let expandedFolders = new Set();
    let referenceTarget = '';
    let isProgrammaticScroll = false;

    function saveState() {
      localStorage.setItem('markdown-editor-state', JSON.stringify({
        currentFileId,
        currentFolderId,
        expandedFolders: Array.from(expandedFolders)
      }));
    }

    function loadState() {
      try {
        const state = localStorage.getItem('markdown-editor-state');
        if (state) {
          const parsed = JSON.parse(state);
          currentFileId = parsed.currentFileId || null;
          currentFolderId = parsed.currentFolderId || null;
          expandedFolders = new Set(parsed.expandedFolders || []);
        }
      } catch (e) {
        console.error('Error loading state:', e);
      }
    }

    function initializeExampleFile() {
      if (Object.keys(data.files).length === 0 && Object.keys(data.folders).length === 0) {
        const exampleFileId = generateId();
        const exampleContent = `# Welcome to SnapMD 

This is a **simple** markdown editor with live preview.

## Features

- Split-screen editor and preview
- Download as Markdown (.md)
- Export as PDF
- Export/Import Project as ZIP
- Works completely offline

## Example Code

\`\`\`javascript
function hello() {
  console.log("Hello, World!");
}
\`\`\`

## Lists

1. First item
2. Second item
3. Third item

> This is a blockquote
`;

        data.files[exampleFileId] = {
          id: exampleFileId,
          name: 'example.md',
          content: exampleContent,
          folderId: null,
          createdAt: Date.now(),
          updatedAt: Date.now()
        };

        saveStorage();
        openFile(exampleFileId);
        return true;
      }
      return false;
    }

    function initialRender() {
      loadState();
      renderSidebar();

      const fileToOpen = currentFileId && data.files[currentFileId] ? currentFileId : null;

      if (!fileToOpen) {
        const createdExample = initializeExampleFile();
        if (!createdExample && Object.keys(data.files).length > 0) {
          const firstFileId = Object.keys(data.files)[0];
          openFile(firstFileId);
        }
      } else {
        openFile(fileToOpen);
      }
    }

    function getStorage() {
      try {
        const stored = localStorage.getItem('markdown-editor-data');
        if (stored) {
          return JSON.parse(stored);
        }
        return { folders: {}, files: {} };
      } catch (e) {
        console.error('Storage error:', e);
        return { folders: {}, files: {} };
      }
    }

    function saveStorage() {
      localStorage.setItem('markdown-editor-data', JSON.stringify(data));
    }

    function generateId() {
      return 'id-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);
    }

    function createFile(name = null, content = '') {
      const folderId = currentFolderId;
      const fileId = generateId();
      const fileName = name || prompt('Enter file name:', 'untitled.md');

      if (!fileName) return;

      data.files[fileId] = {
        id: fileId,
        name: fileName,
        content: content,
        folderId: folderId,
        createdAt: Date.now(),
        updatedAt: Date.now()
      };

      if (folderId && data.folders[folderId]) {
        if (!data.folders[folderId].files) {
          data.folders[folderId].files = [];
        }
        data.folders[folderId].files.push(fileId);
      }

      saveStorage();
      openFile(fileId);
      saveState();
      renderSidebar();
    }

    function createFolder(name = null) {
      const parentId = currentFolderId;
      const folderId = generateId();
      const folderName = name || prompt('Enter folder name:', 'New Folder');

      if (!folderName) return;

      data.folders[folderId] = {
        id: folderId,
        name: folderName,
        files: [],
        parentId: currentFolderId,
        children: [],
        createdAt: Date.now()
      };

      if (parentId && data.folders[parentId]) {
        if (!data.folders[parentId].children) {
          data.folders[parentId].children = [];
        }
        data.folders[parentId].children.push(folderId);
      }

      saveStorage();
      saveState();
      renderSidebar();
    }

    function renameFile(fileId) {
      const file = data.files[fileId];
      const newName = prompt('Enter new name:', file.name);

      if (newName && newName !== file.name) {
        file.name = newName;
        file.updatedAt = Date.now();
        saveStorage();
        renderSidebar();
      }
    }

    function deleteFile(fileId) {
      const file = data.files[fileId];

      if (confirm('Delete file "' + file.name + '"?')) {
        delete data.files[fileId];

        if (file.folderId && data.folders[file.folderId]) {
          const folder = data.folders[file.folderId];
          const folderFiles = data.folders[file.folderId].files || [];
          const index = folderFiles.indexOf(fileId);
          if (index > -1) {
            folderFiles.splice(index, 1);
          }
        }

        saveStorage();
        if (currentFileId === fileId) {
          currentFileId = null;
          editor.value = '';
          updatePreview();
        }
        renderSidebar();
      }
    }

    function renameFolder(folderId) {
      const folder = data.folders[folderId];
      const newName = prompt('Enter new folder name:', folder.name);

      if (newName && newName !== folder.name) {
        folder.name = newName;
        saveStorage();
        renderSidebar();
      }
    }

    function deleteFolder(folderId) {
      const folder = data.folders[folderId];

      if (confirm('Delete folder "' + folder.name + '" and all its contents?')) {
        deleteFolderRecursive(folderId);
        saveStorage();
        renderSidebar();
      }
    }

    function deleteFolderRecursive(folderId) {
      const folder = data.folders[folderId];
      if (!folder) return;

      const files = folder.files || [];
      files.forEach(fileId => {
        delete data.files[fileId];
      });

      const children = folder.children || [];
      children.forEach(childId => {
        deleteFolderRecursive(childId);
      });

      delete data.folders[folderId];

      if (folder.parentId && data.folders[folder.parentId]) {
        const parent = data.folders[folder.parentId];
        const index = (parent.children || []).indexOf(folderId);
        if (index > -1) {
          parent.children.splice(index, 1);
        }
      }

      if (currentFolderId === folderId) {
        currentFolderId = null;
      }
    }

    function openFile(fileId) {
      const file = data.files[fileId];
      if (file) {
        saveCurrentFile();
        currentFileId = fileId;
        currentFolderId = file.folderId || null;
        editor.value = file.content;
        updatePreview();
        renderSidebar();
      }
    }

    function toggleFolderExpand(folderId) {
      if (expandedFolders.has(folderId)) {
        expandedFolders.delete(folderId);
      } else {
        expandedFolders.add(folderId);
      }
      saveState();
      renderSidebar();
    }

    function selectFolder(folderId) {
      currentFolderId = folderId;
      saveState();
      renderSidebar();
    }

    function deselectFolder() {
      if (currentFolderId !== null) {
        currentFolderId = null;
        saveState();
        renderSidebar();
      }
    }

    function toggleSidebar() {
      const sidebar = document.getElementById('sidebar');
      sidebar.classList.toggle('collapsed');
    }

    function createNewFile() {
      closeDropdowns();
      createFile();
    }

    function createNewFolder() {
      closeDropdowns();
      createFolder();
    }

    function toggleDropdown(id, forceShow = null) {
      const dropdown = document.getElementById(id);
      if (forceShow !== null) {
        dropdown.classList.toggle('show', forceShow);
      } else {
        dropdown.classList.toggle('show');
      }
    }

    function closeDropdowns() {
      document.querySelectorAll('.dropdown-content').forEach(d => d.classList.remove('show'));
    }

    function saveCurrentFile() {
      if (!currentFileId) return;

      if (data.files[currentFileId]) {
        data.files[currentFileId].content = editor.value;
        data.files[currentFileId].updatedAt = Date.now();
        saveStorage();
      }
    }

    function clearEditor() {
      if (confirm('Clear editor?')) {
        editor.value = '';
        updatePreview();
      }
    }

    function showHelp() {
      document.getElementById('help-modal').classList.add('show');
    }

    function closeHelp() {
      document.getElementById('help-modal').classList.remove('show');
    }

    function openFileDialog(event) {
      event.preventDefault();
      document.getElementById('file-input').click();
    }

    function downloadMarkdown(event) {
      if (event) {
        event.preventDefault();
      }
      const blob = new Blob([editor.value], { type: 'text/markdown' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'document.md';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    function exportPDF(event) {
      if (event) {
        event.preventDefault();
      }
      const opt = {
        margin: 10,
        filename: 'document.pdf',
        image: { type: 'jpeg', quality: 0.98 },
        html2canvas: { scale: 2 },
        jsPDF: { unit: 'mm', format: 'a4', orientation: 'portrait' }
      };
      html2pdf().set(opt).from(preview).save();
    }

    function exportZIP(event) {
      if (event) {
        event.preventDefault();
      }

      const zip = new JSZip();

      function addFolderToZip(folderId, path) {
        const folder = data.folders[folderId];
        if (!folder) return;

        const folderPath = path ? `${path}/${folder.name}` : folder.name;

        if (folder.children) {
          folder.children.forEach(childId => {
            addFolderToZip(childId, folderPath);
          });
        }

        if (folder.files) {
          folder.files.forEach(fileId => {
            const file = data.files[fileId];
            if (file) {
              zip.file(`${folderPath}/${file.name}`, file.content);
            }
          });
        }
      }

      Object.keys(data.folders).forEach(folderId => {
        const folder = data.folders[folderId];
        if (!folder.parentId) {
          addFolderToZip(folderId, '');
        }
      });

      Object.keys(data.files).forEach(fileId => {
        const file = data.files[fileId];
        if (!file.folderId) {
          zip.file(file.name, file.content);
        }
      });

      const zipFileName = 'markdown-editor-project.zip';

      return zip.generateAsync({ type: 'blob' }).then(function(content) {
        saveAs(content, zipFileName);
      });
    }

    function importZIP(event) {
      if (event) {
        event.preventDefault();
      }
      document.getElementById('zip-input').click();
    }

    function processZIPFile(file) {
      const reader = new FileReader();

      reader.onload = function(e) {
        const zip = new JSZip();

        zip.loadAsync(e.target.result).then(function(zip) {
          if (confirm('Import will replace all existing files and folders. Continue?')) {
            data = { folders: {}, files: {} };
            const folderMap = new Map();

            const entries = [];

            zip.forEach(function(relativePath, zipEntry) {
              entries.push({ path: relativePath, entry: zipEntry });
            });

            entries.sort((a, b) => a.path.localeCompare(b.path));

            entries.forEach(function(item) {
              const relativePath = item.path;
              const zipEntry = item.entry;

              if (relativePath.endsWith('/')) {
                const folderId = generateId();
                const folderName = relativePath.slice(0, -1);
                const parts = folderName.split('/');
                const name = parts[parts.length - 1];

                const parentPath = parts.slice(0, -1).join('/');
                const parentId = parentPath ? folderMap.get(parentPath) : null;

                folderMap.set(folderName, folderId);

                data.folders[folderId] = {
                  id: folderId,
                  name: name,
                  files: [],
                  parentId: parentId,
                  children: [],
                  createdAt: Date.now()
                };

                if (parentId && data.folders[parentId]) {
                  if (!data.folders[parentId].children) {
                    data.folders[parentId].children = [];
                  }
                  data.folders[parentId].children.push(folderId);
                }
              } else {
                const fileId = generateId();
                const fileName = relativePath.split('/').pop();
                const folderPath = relativePath.substring(0, relativePath.lastIndexOf('/'));
                const folderId = folderMap.get(folderPath);

                zipEntry.async('text').then(function(content) {
                  data.files[fileId] = {
                    id: fileId,
                    name: fileName,
                    content: content,
                    folderId: folderId,
                    createdAt: Date.now(),
                    updatedAt: Date.now()
                  };

                  if (folderId && data.folders[folderId]) {
                    if (!data.folders[folderId].files) {
                      data.folders[folderId].files = [];
                    }
                    data.folders[folderId].files.push(fileId);
                  }

                  saveStorage();
                  renderSidebar();
                });
              }
            });

            saveStorage();
            renderSidebar();
          }
        });
      };

      reader.readAsArrayBuffer(file);
    }

    try {
      marked.use({
        gfm: true,
        breaks: false
      });
    } catch (e) {
      console.error('Error configuring marked:', e);
    }

    function renderFolder(folderId, level = 0, searchTerm = '') {
      const folder = data.folders[folderId];
      if (!folder) return '';

      const indent = level * 20;
      const isExpanded = expandedFolders.has(folderId);
      const hasChildren = (folder.children && folder.children.length > 0) || (folder.files && folder.files.length > 0);
      const matchesSearch = !searchTerm || folder.name.toLowerCase().includes(searchTerm.toLowerCase());

      let html = '';

      if (matchesSearch) {
        const isActive = currentFolderId === folderId;
        const chevron = hasChildren ? '‚ñ∂' : '‚Ä¢';

        html += `
          <div class="sidebar-item ${isActive ? 'active' : ''}" style="padding-left: ${10 + indent}px" data-type="folder" data-id="${folderId}">
            <span class="sidebar-chevron ${isExpanded ? 'expanded' : ''}" data-action="expand" data-id="${folderId}">${chevron}</span>
            <span class="sidebar-item-icon">üìÅ</span>
            <span class="sidebar-item-name">${folder.name}</span>
            <div class="sidebar-item-actions">
              <button class="sidebar-item-action-btn" data-action="rename-folder" data-id="${folderId}">‚úé</button>
              <button class="sidebar-item-action-btn" data-action="delete-folder" data-id="${folderId}">√ó</button>
            </div>
          </div>
        `;
      }

      if (isExpanded || searchTerm) {
        html += '<div class="sidebar-children">';

        if (folder.children) {
          folder.children.forEach(childId => {
            html += renderFolder(childId, level + 1, searchTerm);
          });
        }

        if (folder.files) {
          folder.files.forEach(fileId => {
            html += renderFile(fileId, level + 1, searchTerm);
          });
        }

        html += '</div>';
      }

      return html;
    }

    function renderFile(fileId, level = 0, searchTerm = '') {
      const file = data.files[fileId];
      if (!file) return '';

      const indent = level * 20;
      const matchesSearch = !searchTerm || file.name.toLowerCase().includes(searchTerm.toLowerCase());

      if (!matchesSearch) return '';

      const isActive = currentFileId === fileId;

      return `
        <div class="sidebar-item ${isActive ? 'active' : ''}" style="padding-left: ${10 + indent}px" data-type="file" data-id="${fileId}">
          <span class="sidebar-item-icon">üìÑ</span>
          <span class="sidebar-item-name">${file.name}</span>
          <div class="sidebar-item-actions">
            <button class="sidebar-item-action-btn" data-action="rename-file" data-id="${fileId}">‚úé</button>
            <button class="sidebar-item-action-btn" data-action="delete-file" data-id="${fileId}">√ó</button>
          </div>
        </div>
      `;
    }

    function renderSidebar() {
      const searchTerm = searchInput.value.trim();
      let html = '';

      const rootFolders = Object.keys(data.folders).filter(id => !data.folders[id].parentId);
      const rootFiles = Object.keys(data.files).filter(id => !data.files[id].folderId);

      rootFolders.sort((a, b) => data.folders[a].name.localeCompare(data.folders[b].name));
      rootFiles.sort((a, b) => data.files[a].name.localeCompare(data.files[b].name));

      rootFolders.forEach(folderId => {
        html += renderFolder(folderId, 0, searchTerm);
      });

      rootFiles.forEach(fileId => {
        html += renderFile(fileId, 0, searchTerm);
      });

      sidebarContent.innerHTML = html;

      sidebarContent.querySelectorAll('[data-action]').forEach(el => {
        el.addEventListener('click', (e) => {
          e.stopPropagation();
          const action = el.dataset.action;
          const id = el.dataset.id;

          switch (action) {
            case 'expand':
              toggleFolderExpand(id);
              break;
            case 'rename-file':
              renameFile(id);
              break;
            case 'delete-file':
              deleteFile(id);
              break;
            case 'rename-folder':
              renameFolder(id);
              break;
            case 'delete-folder':
              deleteFolder(id);
              break;
          }
        });
      });

      sidebarContent.querySelectorAll('[data-type="folder"]').forEach(el => {
        el.addEventListener('click', (e) => {
          if (e.target.dataset.action) return;
          selectFolder(el.dataset.id);
        });
      });

      sidebarContent.querySelectorAll('[data-type="file"]').forEach(el => {
        el.addEventListener('click', (e) => {
          if (e.target.dataset.action) return;
          openFile(el.dataset.id);
        });
      });
    }

    function updatePreview() {
      preview.innerHTML = marked.parse(editor.value);
    }

    editor.addEventListener('input', () => {
      saveCurrentFile();
      updatePreview();
    });
    editor.addEventListener('scroll', () => {
      if (!isProgrammaticScroll) {
        const scrollRatio = editor.scrollTop / (editor.scrollHeight - editor.clientHeight);
        const targetScroll = scrollRatio * (preview.scrollHeight - preview.clientHeight);
        preview.scrollTop = targetScroll;
      }
    });

    // =============================================
    // Keyboard Shortcuts
    // =============================================

    document.addEventListener('keydown', function(e) {
      // Cmd/Ctrl + Shift + L - Create anchor reference target
      if ((e.metaKey || e.ctrlKey) && e.shiftKey && e.key === 'L') {
        e.preventDefault();
        const start = editor.selectionStart;
        const end = editor.selectionEnd;
        const selectedText = editor.value.substring(start, end);
        if (selectedText) {
          const trimmed = selectedText.trim();
          const headerMatch = trimmed.match(/^(#{1,6})\s+(.+)$/);
          if (headerMatch) {
            // If it's a header, use the header text
            referenceTarget = headerMatch[2];
          } else {
            referenceTarget = trimmed;
            const anchor = referenceTarget.toLowerCase().replace(/\s+/g, '-').replace(/[^a-z0-9-]/g, '');
            const anchorTag = `<a id="${anchor}"></a>`;

            const before = editor.value.substring(0, end);
            const after = editor.value.substring(end);

            if (!before.includes(anchorTag)) {
              isProgrammaticScroll = true;
              editor.value = before + anchorTag + after;
              updatePreview();
              setTimeout(() => {
                isProgrammaticScroll = false;
              }, 100);
            }
          }
        }
      }
    });

    editor.addEventListener('paste', function(e) {
      const clipboardData = e.clipboardData || window.clipboardData;
      const pastedText = clipboardData.getData('text/plain');

      if (!pastedText) return;

      const start = editor.selectionStart;
      const end = editor.selectionEnd;
      const selectedText = editor.value.substring(start, end);

      if (referenceTarget) {
        // Paste with reference ‚Üí Create link to anchor
        e.preventDefault();
        const anchor = referenceTarget.toLowerCase().replace(/\s+/g, '-').replace(/[^a-z0-9-]/g, '');
        let markdownLink;

        if (selectedText) {
          markdownLink = `[${selectedText}](#${anchor})`;
        } else {
          markdownLink = `[${referenceTarget}](#${anchor})`;
        }

        insertText(markdownLink);
        referenceTarget = null;
        return;
      }

      // Check if pasted text is a URL
      if (isValidUrl(pastedText)) {
        if (selectedText) {
          e.preventDefault();
          const isImage = /\.(png|jpg|jpeg|gif|svg|webp|bmp|ico)(\?.*)?$/i.test(pastedText);
          const markdown = isImage ? `![${selectedText}](${pastedText})` : `[${selectedText}](${pastedText})`;
          insertText(markdown);
        }
      }
    });

    // =============================================
    // Drag and Drop URL
    // =============================================

    editor.addEventListener('dragover', function(e) {
      e.preventDefault();
      e.dataTransfer.dropEffect = 'copy';
    });

    editor.addEventListener('drop', function(e) {
      e.preventDefault();

      const draggedText = e.dataTransfer.getData('text/plain');
      if (!draggedText) return;

      const selection = editor.value.substring(editor.selectionStart, editor.selectionEnd);

      if (selection) {
        let replacement;

        if (referenceTarget) {
          // Drop with reference ‚Üí Create link to anchor
          const anchor = referenceTarget.toLowerCase().replace(/\s+/g, '-').replace(/[^a-z0-9-]/g, '');
          replacement = `[${selection}](#${anchor})`;
          referenceTarget = null;
        } else if (isValidUrl(draggedText)) {
          // Check if dropped text is a URL
          const isImage = /\.(png|jpg|jpeg|gif|svg|webp|bmp|ico)(\?.*)?$/i.test(draggedText);
          replacement = isImage ? `![${selection}](${draggedText})` : `[${selection}](${draggedText})`;
        } else {
          // Just insert normally
          replacement = selection + draggedText;
        }

        insertText(replacement);
      }
    });

    // =============================================
    // Helper Functions
    // =============================================

    function isValidUrl(string) {
      try {
        new URL(string);
        return true;
      } catch (_) {
        return false;
      }
    }

    function insertText(text) {
      isProgrammaticScroll = true;
      const start = editor.selectionStart;
      const end = editor.selectionEnd;
      editor.value = editor.value.substring(0, start) + text + editor.value.substring(end);
      editor.focus();
      editor.selectionStart = editor.selectionEnd = start + text.length;
      saveCurrentFile();
      updatePreview();
      setTimeout(() => {
        isProgrammaticScroll = false;
      }, 100);
    }

    // =============================================
    // Preview Click Actions
    // =============================================

    preview.addEventListener('click', function(e) {
      // Handle link clicks
      const link = e.target.closest('a[href^="#"]');
      if (link) {
        e.preventDefault();
        const targetId = link.getAttribute('href').substring(1);
        const targetElement = document.getElementById(targetId);

        if (targetElement) {
          targetElement.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }
        return;
      }

      // Handle regular clicks - focus editor and select clicked text
      const target = e.target;
      const clickedText = (target.textContent || target.innerText).trim();
      
      // Find and select exact word/text in editor (with word boundary check)
      if (clickedText && clickedText.length >= 1) {
        const editorText = editor.value;
        let foundIndex = -1;

        // Search for clicked text with word boundary checking
        for (let i = 0; i <= editorText.length - clickedText.length; i++) {
          const substring = editorText.substring(i, i + clickedText.length);
          if (substring === clickedText) {
            // Check if it's a word boundary
            const beforeChar = i > 0 ? editorText[i - 1] : '';
            const afterChar = i + clickedText.length < editorText.length ? editorText[i + clickedText.length] : '';

            const isBoundary = (
              // Start of string
              i === 0 ||
              // End of string
              i + clickedText.length === editorText.length ||
              // Word boundary characters (space, punctuation, symbols)
              /[\s\p{P}\p{S}\p{N}\p{C}]/u.test(beforeChar) ||
              /[\s\p{P}\p{S}\p{N}\p{C}]/u.test(afterChar)
            );

            if (isBoundary) {
              foundIndex = i;
              break;
            }
          }
        }
        
        if (foundIndex >= 0) {
          const endIndex = foundIndex + clickedText.length;

          // Calculate line to scroll to
          const textBefore = editorText.substring(0, endIndex);
          const lineNum = textBefore.split('\n').length - 1;

          isProgrammaticScroll = true;
          const lineHeight = 22.4;
          const scrollTop = Math.max(0, lineNum * lineHeight - editor.clientHeight / 2);
          editor.scrollTop = scrollTop;
          
          editor.focus();
          editor.selectionStart = foundIndex;
          editor.selectionEnd = endIndex;
          
          setTimeout(() => {
            isProgrammaticScroll = false;
          }, 100);
        }
      }
    });
    document.getElementById('file-input').addEventListener('change', function(e) {
      const file = e.target.files[0];
      if (file) {
        const reader = new FileReader();
        reader.onload = function(e) {
          createFile(file.name, e.target.result);
        };
        reader.readAsText(file);
      }
      this.value = '';
    });

    // =============================================
    // Drag and Drop Files to Sidebar
    // =============================================

    sidebarContent.addEventListener('dragover', function(e) {
      e.preventDefault();
      e.dataTransfer.dropEffect = 'copy';
      sidebarContent.classList.add('drag-over');
    });

    sidebarContent.addEventListener('dragleave', function(e) {
      e.preventDefault();
      sidebarContent.classList.remove('drag-over');
    });

    sidebarContent.addEventListener('drop', function(e) {
      e.preventDefault();
      sidebarContent.classList.remove('drag-over');

      const files = e.dataTransfer.files;
      if (files.length === 0) return;

      const folderId = currentFolderId;

      for (let i = 0; i < files.length; i++) {
        const file = files[i];
        if (file.name.toLowerCase().endsWith('.md') || file.name.toLowerCase().endsWith('.markdown')) {
          const reader = new FileReader();
          reader.onload = function(e) {
            const fileId = generateId();
            data.files[fileId] = {
              id: fileId,
              name: file.name,
              content: e.target.result,
              folderId: folderId,
              createdAt: Date.now(),
              updatedAt: Date.now()
            };

            if (folderId && data.folders[folderId]) {
              if (!data.folders[folderId].files) {
                data.folders[folderId].files = [];
              }
              data.folders[folderId].files.push(fileId);
            }

            saveStorage();
            renderSidebar();

            if (i === 0) {
              openFile(fileId);
            }
          };
          reader.readAsText(file);
        }
      }
    });

    document.getElementById('zip-input').addEventListener('change', function(e) {
      const file = e.target.files[0];
      if (file) {
        processZIPFile(file);
      }
      this.value = '';
    });

    searchInput.addEventListener('input', function() {
      renderSidebar();
    });

    document.getElementById('sidebar-toggle').addEventListener('click', toggleSidebar);
    document.getElementById('menu-file').addEventListener('click', (e) => {
      e.stopPropagation();
      e.preventDefault();
      const dropdown = document.getElementById('file-menu');
      dropdown.classList.toggle('show');
    });
    document.getElementById('menu-new-file').addEventListener('click', (e) => {
      e.stopPropagation();
      e.preventDefault();
      document.getElementById('file-menu').classList.remove('show');
      setTimeout(() => createFile(), 50);
    });
    document.getElementById('menu-new-folder').addEventListener('click', (e) => {
      e.stopPropagation();
      e.preventDefault();
      document.getElementById('file-menu').classList.remove('show');
      setTimeout(() => createFolder(), 50);
    });
    document.getElementById('menu-open').addEventListener('click', (e) => {
      e.stopPropagation();
      e.preventDefault();
      closeDropdowns();
      openFileDialog(e);
    });
    document.getElementById('menu-download').addEventListener('click', (e) => {
      e.stopPropagation();
      e.preventDefault();
      closeDropdowns();
      downloadMarkdown(e);
    });
    document.getElementById('menu-export').addEventListener('click', (e) => {
      e.stopPropagation();
      e.preventDefault();
      closeDropdowns();
      exportPDF(e);
    });
    document.getElementById('menu-export-zip').addEventListener('click', (e) => {
      e.stopPropagation();
      e.preventDefault();
      closeDropdowns();
      exportZIP(e);
    });
    document.getElementById('menu-import-zip').addEventListener('click', (e) => {
      e.stopPropagation();
      e.preventDefault();
      closeDropdowns();
      importZIP(e);
    });
    document.getElementById('menu-clear').addEventListener('click', (e) => {
      e.stopPropagation();
      e.preventDefault();
      closeDropdowns();
      clearEditor();
    });
    document.getElementById('menu-help').addEventListener('click', (e) => {
      e.stopPropagation();
      e.preventDefault();
      closeDropdowns();
      showHelp();
    });
    document.getElementById('close-help').addEventListener('click', (e) => {
      e.stopPropagation();
      closeHelp();
    });

    document.addEventListener('click', (e) => {
      if (!e.target.closest('.dropdown')) {
        const dropdowns = document.querySelectorAll('.dropdown-content');
        dropdowns.forEach(d => d.classList.remove('show'));
      }
    });

    document.getElementById('sidebar-header').addEventListener('click', deselectFolder);
    document.getElementById('sidebar-content').addEventListener('click', (e) => {
      if (!e.target.closest('.sidebar-item')) {
        deselectFolder();
      }
    });

    document.addEventListener('DOMContentLoaded', () => {
      initialRender();
    });
  </script>
</body>
</html>
